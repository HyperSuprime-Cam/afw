// -*- lsst-c++ -*-
#ifndef AFW_TABLE_Source_h_INCLUDED
#define AFW_TABLE_Source_h_INCLUDED

#include "lsst/afw/detection/Footprint.h"
#include "lsst/afw/table/RecordInterface.h"
#include "lsst/afw/table/TableInterface.h"

namespace lsst { namespace afw { namespace table {

typedef detection::Footprint Footprint;

class SourceRecord;
class SourceTable;

/// @brief A tag class for SourceTable and SourceRecord to be used with the interface classes.
struct Source {
    typedef SourceRecord Record;
    typedef SourceTable Table;

    class RecordAux : public AuxBase {
    public:
        Footprint footprint;
        
        explicit RecordAux(Footprint const & fp) : footprint(fp) {}
    };

};

/**
 *  @brief A bare-bones record class intended for testing and generic tabular data.
 */
class SourceRecord : public RecordInterface<Source> {
public:

    bool hasFootprint() const { return getAux(); }

    Footprint const & getFootprint() const {
        return boost::static_pointer_cast<Source::RecordAux>(getAux())->footprint;
    }

private:

    friend class detail::Access;

    SourceRecord(RecordBase const & other) : RecordInterface<Source>(other) {}
};

/**
 *  @brief A bare-bones record class intended for testing and generic tabular data.
 */
class SourceTable : public TableInterface<Source> {
public:

    /**
     *  @brief Construct a new table.
     *
     *  @param[in] schema            Schema that defines the fields, offsets, and record size for the table.
     *  @param[in] capacity          Number of records to pre-allocate space for in the first block.  This
     *                               overrides nRecordsPerBlock for the first block and the first block only.
     *  @param[in] idFactory         Factory class to generate record IDs when they are not explicitly given.
     *                               If empty, defaults to a simple counter that starts at 1.
     */
    SourceTable(
        Schema const & schema,
        int capacity = 0,
        PTR(IdFactory) const & idFactory = PTR(IdFactory)()
    ) : TableInterface<Source>(schema, capacity, idFactory) {}
    
    /// @brief Create and add a new record with an ID generated by the table's IdFactory.
    Record addRecord() const { return _addRecord(); }
    
    /// @brief Create and add a new record with an ID generated by the table's IdFactory.
    Record addRecord(Footprint const & footprint) const {
        return _addRecord(boost::make_shared<Source::RecordAux>(footprint));
    }

    /// @brief Create and add a new record with an explicit RecordId.
    Record addRecord(RecordId id) const { return _addRecord(id); }

    /// @brief Create and add a new record with an explicit RecordId.
    Record addRecord(RecordId id, Footprint const & footprint) const {
        return _addRecord(id, boost::make_shared<Source::RecordAux>(footprint));
    }

    /**
     *  @brief Write a FITS binary table.
     *
     *  @param[in]   filename        Name of the FITS file to open.  This will be passed directly
     *                               to cfitsio, so all of its extended filename syntaxes should
     *                               work here.
     *  @param[in]   sanitizeNames   If true, periods in names will be converted to underscores.
     */
    void writeFits(std::string const & filename);
    
    /**
     *  @brief Load a table from a FITS binary table.
     *
     *  @param[in]   filename        Name of the FITS file to open.  This will be passed directly
     *                               to cfitsio, so all of its extended filename syntaxes should
     *                               work here.
     */
    static SourceTable readFits(std::string const & filename);

};

}}} // namespace lsst::afw::table

#endif // !AFW_TABLE_Source_h_INCLUDED
